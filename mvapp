#!/usr/bin/env python
# -*- coding: utf-8 -*-

import datetime
import getopt
import os
import plistlib
import subprocess
import sys
import zipfile


DEFAULT_APPS_PATH    = '~/Music/iTunes/iTunes Media/Mobile Applications'
DEFAULT_BACKUPS_PATH = '~/Library/Application Support/MobileSync/Backup'
DEFAULT_DEVICE_ID    = None
VERSION              = '1.0'

def path_items(path):
  """Return items (directories, files, ...) in path."""
  return [os.path.join(path, f) for f in os.listdir(path)]


def is_ipa(filename):
  """Filter *.ipa files."""
  return os.path.isfile(filename) and '.ipa' == os.path.splitext(filename)[-1]
  

def extract_plist(zipfilename):
  """Extract iTunesMetadata.plist file from ipa zip file."""
  try:
    zfile = zipfile.ZipFile(zipfilename)
    data  = zfile.read('iTunesMetadata.plist')
  finally:
    zfile.close()
  return data


def read_plist(plist):
  """Read binary/xml plist data/file."""
  if plist.find('\x00') < 0 and os.path.isfile(plist):
    try:
      file = open(plist)
      data = read_plist_string(file.read())
    finally:
      file.close()
    return data
  else:
    return read_plist_string(plist)


def read_plist_string(plist):
  """Read binary/xml plist data."""
  if plist.startswith('bplist'):
    proc = subprocess.Popen(['plutil', '-convert', 'xml1', '-o', '-', '-'], \
                            stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    proc.stdin.write(plist)
    return plistlib.readPlistFromString(proc.communicate()[0])
  else:
    return plistlib.readPlistFromString(plist)


def release_date(metadata):
  """Query for release date."""
  return metadata.get('releaseDate')


def purchase_date(metadata):
  """Query for purchase date."""
  if 'purchaseDate' in metadata:
    return metadata.get('purchaseDate')
  else:
    info = metadata.get('com.apple.iTunesStore.downloadInfo')
    return info.get('purchaseDate')


def bundle_id(metadata):
  """Query for software version bundle id."""
  return metadata.get('softwareVersionBundleId')

def aggregate(zipfilename):
  """Aggregate the release and purchase date for an ipa file."""
  metadata = read_plist(extract_plist(zipfilename))
  return {
      'filename': zipfilename,
      'app_name': bundle_id(metadata),
      'release_date': release_date(metadata),
      'purchase_date': purchase_date(metadata)
  }


def installed_apps(backups_path, device):
  """Return a list of installed apps on a given device."""
  # return {{LATEST_BACKUP}}/HASH(Library/SpringBoard/IconState.plist) > ...
  # return {{LATEST_BACKUP}}/Info.plist > iTunes Settings/Library Applications/*
  # return {{LATEST_BACKUP}}/Manifest.plist > Applications/*
  latest = latest_backup(backups_path, device)
  latest_path = os.path.join(backups_path, latest, 'Manifest.plist')
  apps = read_plist(latest_path).get('Applications')
  return apps.keys()


def backup_info(backup_path):
  """Read backup info."""
  return read_plist(os.path.join(backup_path, 'Info.plist'))


def latest_backup(backups_path, device):
  """Return path to latest backup"""
  backup_paths   = filter(os.path.isdir, path_items(backups_path))
  backups        = map(backup_info, backup_paths)
  device_backups = filter(lambda backup: is_device(device, backup), backups)
  sorter         = lambda backup: backup.get('Last Backup Date', datetime.datetime.min)
  sorted_backups = sorted(device_backups, key=sorter, reverse=True)
  return first(sorted_backups).get('Unique Identifier').lower()


def first(list):
  """Return first item in list or None."""
  if list:
    return list[0]
  else:
    return None


def is_device(device, info):
  """Check if device has device/display name, GUID, IMEI or serial number."""
  if device == None:
    return True
  return device in [info.get('Device Name'),
                    info.get('Display Name'),
                    info.get('GUID'),
                    info.get('ICCID'),
                    info.get('IMEI'),
                    info.get('Serial Number')]


def installed(metadata, installed_apps):
  """Predicate if app is installed."""
  return metadata.get('app_name') in installed_apps


def usage():
  """Shows usage/help screen."""
  return '''Usage: %s [options...] <file>
Options:
 -a, --apps-path=<path>     Non-default path to downloaded apps by iTunes
 -b, --backups-path=<path>  Non-default path to device backups
 -d, --device-id=<device>   Device id (name, GUID, ICCID, IMEI, serial number)
 -v, --version              Show version info
 -h, --help                 Show usage screen''' % os.path.basename(sys.argv[0])


def exit(code, str):
  """Write error to stderr if exit code not 0 and exits with exit code."""
  if code:
    sys.stderr.write(str + '\n')
  else:
    print str
  return code


def main(argv=None):
  if not argv: argv = sys.argv[1:]
  try:
    long_opts = ['help', 'version', 'apps-path=', 'backups-path=', 'device-id=']
    opts, args = getopt.getopt(argv, 'hva:b:d:', long_opts)
  except getopt.GetoptError as err:
    return exit(1, str(err) + '\n' + usage())
  
  apps_path    = DEFAULT_APPS_PATH
  backups_path = DEFAULT_BACKUPS_PATH
  device_id    = DEFAULT_DEVICE_ID
  
  for o, a in opts:
    if (o in ['-h', '--help']):
      return exit(0, usage())
    elif (o in ['-v', '--version']):
      return exit(0, VERSION)
    elif (o in ['-a', '--apps-path']):
      apps_path = a
    elif (o in ['-b', '--backups-path']):
      backups_path = a
    elif (o in ['-d', '--device-id']):
      device_id = a
    else:
      return exit(1, 'invalid argument: "%s".' % a)
  
  try:
    ipa_path  = os.path.expanduser(apps_path)
    ipa_files = filter(is_ipa, path_items(ipa_path))
    down_apps = map(aggregate, ipa_files)
    inst_apps = installed_apps(os.path.expanduser(backups_path), device_id)
    purc_apps = filter(lambda app: installed(app, inst_apps), down_apps)
    rel_mvps  = sorted(purc_apps, key=lambda app: app.get('release_date'))
    pur_mvps  = sorted(purc_apps, key=lambda app: app.get('purchase_date'))
    print 'MVP (by release date) : ', first(rel_mvps).get('app_name')
    print 'MVP (by purchase date): ', first(pur_mvps).get('app_name')
  except Exception as e:
    return exit(1, str(e))

if __name__ == '__main__':
  sys.exit(main())
